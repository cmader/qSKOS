package at.ac.univie.mminf.qskos4j.cmd;

import at.ac.univie.mminf.qskos4j.issues.Issue;
import at.ac.univie.mminf.qskos4j.result.Result;
import org.eclipse.rdf4j.OpenRDFException;
import org.eclipse.rdf4j.RDF4JException;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.LiteralImpl;
import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryResult;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.rio.RDFWriter;
import org.eclipse.rdf4j.rio.Rio;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;


class ReportCollector {

	private final Logger logger = LoggerFactory.getLogger(ReportCollector.class);

	private Collection<Issue> issues;
	private String reportFileName;
	private Collection<String> vocabFileNames;
	private boolean includeSummary;
	private boolean inDQV;

	private String computedOn;

	public ReportCollector(Collection<Issue> issues,
			String reportFileName,
			Collection<String> vocabFileNames,
			boolean includeSummary, boolean inDQV, String analizedDataset) {
		this.issues = issues;
		this.reportFileName = reportFileName;
		this.includeSummary = includeSummary;
		this.vocabFileNames = vocabFileNames;
		this.inDQV= inDQV;
		this.computedOn = analizedDataset;
	}

	void outputIssuesReport(boolean shouldWriteGraphs)
			throws IOException, RDF4JException
	{

		File reportFile = createReportFile();
		BufferedWriter reportWriter = new BufferedWriter(new FileWriter(reportFile));

		processIssues();

		String reportSummary = "";
		if (includeSummary) {
			reportSummary = createReportSummary();
			logger.info("\n" +reportSummary);
		}
		writeReportHeader(reportWriter, reportFile, reportSummary);
		writeReportBody(reportWriter, reportFile, shouldWriteGraphs);

		if (this.inDQV) {
			File DQVFile = createDQVFile();
			FileOutputStream out = new FileOutputStream(DQVFile, true);
			RDFWriter writer = Rio.createWriter(RDFFormat.TURTLE, out);
			logger.info("\n" + "Writing results as instances of the Data Quality Vocabulary"); 
			writeDQVReportBody(writer, DQVFile, shouldWriteGraphs);
			logger.info("\n" + "DQV file:" + DQVFile.getPath()); 
			out.close();
		}

		reportWriter.close();


	}

	private void writeReportHeader(BufferedWriter reportWriter,
			File vocabFile,
			String reportSummary) throws IOException
	{
		String issuedDate = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z").format(new Date());
		reportWriter.write("This is the quality report of the file(s) ");
		Iterator<String> vocabIt = vocabFileNames.iterator();
		while (vocabIt.hasNext()) {
			String vocabFileName = vocabIt.next();
			reportWriter.write(vocabFileName);
			if (vocabIt.hasNext()) reportWriter.write(", ");
		}
		reportWriter.write(", generated by qSKOS on " +issuedDate);
		reportWriter.newLine();
		reportWriter.newLine();
		reportWriter.write(reportSummary);
	}

	private void processIssues() throws RDF4JException {
		int issueNumber = 0;
		Iterator<Issue> issueIt = issues.iterator();
		while (issueIt.hasNext()) {
			Issue issue = issueIt.next();
			issueNumber++;

			logger.info("Processing issue " + issueNumber + " of " + issues.size() + " (" + issue.getName() + ")");
			issue.getResult();

		}

		logger.info("Report complete!");
	}

	private String createReportSummary() throws IOException, RDF4JException {
		StringBuffer summary = new StringBuffer();
		summary.append("* Summary of Quality Issue Occurrences:\n");

		for (Issue issue : issues) {
			summary.append(issue.getName() + ": " + prepareOccurrenceText(issue) + "\n");
		}

		summary.append("\n");
		return summary.toString();
	}

	private String prepareOccurrenceText(Issue issue) throws RDF4JException {
		String occurrenceText = "";
		if (issue.getResult().isProblematic()) {
			occurrenceText = "FAIL";
			try {
				String occurrenceCount = Long.toString(issue.getResult().occurrenceCount());
				occurrenceText += " (" +occurrenceCount+ ")";
			}
			catch (UnsupportedOperationException e) {
				// ignore this
			}
		}
		else {
			occurrenceText = "OK (no potential problems found)";
		}

		return occurrenceText;
	}

	private void writeReportBody(BufferedWriter reportWriter,
			File reportFile,
			boolean shouldWriteGraphs)
					throws IOException, RDF4JException
	{
		reportWriter.write("* Detailed coverage of each Quality Issue:\n\n");
		Iterator<Issue> issueIt = issues.iterator();
		while (issueIt.hasNext()) {
			Issue issue = issueIt.next();

			writeTextReport(issue, reportWriter);

			if (issueIt.hasNext()) {
				reportWriter.newLine();
			}

			if (shouldWriteGraphs) {
				writeGraphFiles(issue, getDotFilesPath(reportFile));
			}
		}
	}

	private File createReportFile() throws IOException {
		File file = new File(reportFileName);
		file.createNewFile();
		return file;
	}

	private File createDQVFile() throws IOException {
		int ind=reportFileName.lastIndexOf(".");
		String DQVFileName;
		DQVFileName= ind!=1? reportFileName.substring(0,ind )+ ".ttl": reportFileName+ ".ttl";
		File file = new File(DQVFileName);
		file.createNewFile();
		return file;
	}

	private void writeDQVReport(Issue issue, RepositoryConnection repCon, ValueFactory f, String sdate)
			throws IOException, RDF4JException
	{

		String ndqv= "http://www.w3.org/ns/dqv#";
		String nex="http://w3id.org/quality/qskos/";

		IRI ptype=  f.createIRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
		IRI pcomputedOn = f.createIRI(ndqv+"computedOn");
		IRI pdate = f.createIRI("http://purl.org/dc/terms/date");
		IRI pvalue = f.createIRI(ndqv+"value");
		IRI pisMeasurementOf = f.createIRI(ndqv+"isMeasurementOf");

		String datasetName= this.computedOn.substring(this.computedOn.lastIndexOf("/")+1, this.computedOn.length()); 
		IRI measure= f.createIRI(nex+datasetName+issue.getName().replace(" ", "")+sdate);
		repCon.add(measure, ptype, f.createIRI(ndqv+"QualityMeasurement"));

		if (this.computedOn.startsWith("http://"))		repCon.add(measure, pcomputedOn,f.createIRI(this.computedOn));
		else {
			Value datasetPath = new LiteralImpl(this.computedOn, XMLSchema.STRING);
			repCon.add(measure, pcomputedOn,datasetPath);
		}

		Value ldate = new LiteralImpl(sdate, XMLSchema.DATE);
		repCon.add(measure, pdate, ldate);
		int i = new Integer(0);
		String res ;
		Value lval;
		try {
			long r = issue.getResult().occurrenceCount();
			if (issue.getResult().isProblematic())
				res = Long.toString(issue.getResult().occurrenceCount());	
			else
				res = "0";
			 lval = new LiteralImpl( res , XMLSchema.INTEGER);
		}catch (java.lang.UnsupportedOperationException e) {
			// in case the issue is not associated with a list of elements having the problem the methods occurenceCount is not defined. That happen with the issue "No Common Languages:"
			// then we  encode the result as a boolean, plus a annotation explaining .
			if (issue.getResult().isProblematic()) lval = new LiteralImpl( "true" , XMLSchema.BOOLEAN);
			else lval = new LiteralImpl( "false" , XMLSchema.BOOLEAN);
		} 
		repCon.add(measure, pvalue, lval);

		IRI uriDimension= f.createIRI(nex+"numOf"+issue.getName().replace(" ", ""));
		repCon.add(measure, pisMeasurementOf, uriDimension); //issue.getWeblink()

	}

	private String createIssueHeader(Issue issue) {
		String header = "--- " +issue.getName();
		IRI weblink = issue.getWeblink();
		header += "\nDescription: " +issue.getDescription();

		if (weblink != null) {
			header += "\nDetailed information: " +weblink.stringValue();
		}
		return header;
	}

	private String getDotFilesPath(File reportFile) {
		String absolutePath = reportFile.getAbsolutePath();
		return absolutePath.substring(0, absolutePath.lastIndexOf(File.separator));
	}

	private void writeGraphFiles(Issue issue, String dotFilesPath) throws IOException, RDF4JException {
		BufferedWriter graphFileWriter = new BufferedWriter(new FileWriter(dotFilesPath + issue.getId() + ".dot"));
		issue.getResult().generateReport(graphFileWriter, Result.ReportFormat.DOT);
		graphFileWriter.close();
	}

	private void writeDQVReportBody(RDFWriter rdfFile,
			File reportFile,
			boolean shouldWriteGraphs)
					throws IOException, RDF4JException
	{

		Repository myRepository = new SailRepository(new MemoryStore());
		myRepository.initialize();
		ValueFactory factory = myRepository.getValueFactory();
		RepositoryConnection myConnection = myRepository.getConnection();

		//reportWriter.write("* Detailed coverage of each Quality Issue:\n\n");
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String dates = dateFormat.format(date);

		Iterator<Issue> issueIt = issues.iterator();

		while (issueIt.hasNext()) {
			Issue issue = issueIt.next();
			writeDQVReport(issue, myConnection, factory, dateFormat.format(date));
		}

		RepositoryResult<Statement> myGraph = myConnection.getStatements(null, null, null, true);
		try {
			rdfFile.startRDF();
			while (myGraph.hasNext()){
				rdfFile.handleStatement(myGraph.next());
			}
			rdfFile.endRDF();
		}
		catch (RDF4JException e) {
			// oh no, do something!
		}
		finally{
			myGraph.close();
			myConnection.close();
		}
	}

	private void writeTextReport(Issue issue, BufferedWriter writer)
			throws IOException, RDF4JException
	{
		writer.write(createIssueHeader(issue));
		writer.newLine();
		issue.getResult().generateReport(writer, Result.ReportFormat.TXT, Result.ReportStyle.SHORT);

		writer.newLine();
		issue.getResult().generateReport(writer, Result.ReportFormat.TXT, Result.ReportStyle.EXTENSIVE);

		writer.newLine();
		writer.flush();
	}

}
