package at.ac.univie.mminf.qskos4j.cmd;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;

import org.eclipse.rdf4j.RDF4JException;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryResult;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.rio.RDFWriter;
import org.eclipse.rdf4j.rio.Rio;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import at.ac.univie.mminf.qskos4j.issues.Issue;
import at.ac.univie.mminf.qskos4j.result.Result;
import at.ac.univie.mminf.qskos4j.util.IssueDescriptor;

class ReportCollector {

	private final Logger logger = LoggerFactory
			.getLogger(ReportCollector.class);

	private Collection<Issue> issues;
	private String reportFileName;
	private Collection<String> vocabFileNames;
	private boolean includeSummary;
	private boolean inDQV;

	private String computedOn;

	public ReportCollector(final Collection<Issue> issues,
			final String reportFileName,
			final Collection<String> vocabFileNames,
			final boolean includeSummary, final boolean inDQV,
			final String analizedDataset) {
		this.issues = issues;
		this.reportFileName = reportFileName;
		this.includeSummary = includeSummary;
		this.vocabFileNames = vocabFileNames;
		this.inDQV = inDQV;
		this.computedOn = analizedDataset;
	}

	void outputIssuesReport(final boolean shouldWriteGraphs)
			throws IOException, RDF4JException {

		final File reportFile = createReportFile();
		final BufferedWriter reportWriter = new BufferedWriter(new FileWriter(
				reportFile));

		processIssues();

		String reportSummary = "";
		if (this.includeSummary) {
			reportSummary = createReportSummary();
			this.logger.info("\n" + reportSummary);
		}
		writeReportHeader(reportWriter, reportFile, reportSummary);
		writeReportBody(reportWriter, reportFile, shouldWriteGraphs);

		if (this.inDQV) {
			final File DQVFile = createDQVFile();
			final FileOutputStream out = new FileOutputStream(DQVFile, true);
			final RDFWriter writer = Rio.createWriter(RDFFormat.TURTLE, out);
			this.logger
					.info("\n"
							+ "Writing results as instances of the Data Quality Vocabulary");
			writeDQVReportBody(writer, DQVFile, shouldWriteGraphs);
			this.logger.info("\n" + "DQV file:" + DQVFile.getPath());
			out.close();
		}

		reportWriter.close();

	}

	private void writeReportHeader(final BufferedWriter reportWriter,
			final File vocabFile, final String reportSummary)
			throws IOException {
		final String issuedDate = new SimpleDateFormat(
				"EEE, d MMM yyyy HH:mm:ss Z").format(new Date());
		reportWriter.write("This is the quality report of the file(s) ");
		final Iterator<String> vocabIt = this.vocabFileNames.iterator();
		while (vocabIt.hasNext()) {
			final String vocabFileName = vocabIt.next();
			reportWriter.write(vocabFileName);
			if (vocabIt.hasNext())
				reportWriter.write(", ");
		}
		reportWriter.write(", generated by qSKOS on " + issuedDate);
		reportWriter.newLine();
		reportWriter.newLine();
		reportWriter.write(reportSummary);
	}

	private void processIssues() throws RDF4JException {
		int issueNumber = 0;
		final Iterator<Issue> issueIt = this.issues.iterator();
		while (issueIt.hasNext()) {
			final Issue issue = issueIt.next();
			issueNumber++;

			this.logger.info("Processing issue " + issueNumber + " of "
					+ this.issues.size() + " ("
					+ issue.getIssueDescriptor().getName() + ")");
			issue.getResult();

		}

		this.logger.info("Report complete!");
	}

	private String createReportSummary() throws IOException, RDF4JException {
		final StringBuffer summary = new StringBuffer();
		summary.append("* Summary of Quality Issue Occurrences:\n");

		for (final Issue issue : this.issues) {
			summary.append(issue.getIssueDescriptor().getName() + ": "
					+ prepareOccurrenceText(issue) + "\n");
		}

		summary.append("\n");
		return summary.toString();
	}

	private String prepareOccurrenceText(final Issue issue)
			throws RDF4JException {
		String occurrenceText = "";
		if (issue.getResult().isProblematic()) {
			occurrenceText = "FAIL";
			try {
				final String occurrenceCount = Long.toString(issue.getResult()
						.occurrenceCount());
				occurrenceText += " (" + occurrenceCount + ")";
			} catch (final UnsupportedOperationException e) {
				// ignore this
			}
		} else {
			occurrenceText = "OK (no potential problems found)";
		}

		return occurrenceText;
	}

	private void writeReportBody(final BufferedWriter reportWriter,
			final File reportFile, final boolean shouldWriteGraphs)
			throws IOException, RDF4JException {
		reportWriter.write("* Detailed coverage of each Quality Issue:\n\n");
		final Iterator<Issue> issueIt = this.issues.iterator();
		while (issueIt.hasNext()) {
			final Issue issue = issueIt.next();

			writeTextReport(issue, reportWriter);

			if (issueIt.hasNext()) {
				reportWriter.newLine();
			}

			if (shouldWriteGraphs) {
				writeGraphFiles(issue, getDotFilesPath(reportFile));
			}
		}
	}

	private File createReportFile() throws IOException {
		final File file = new File(this.reportFileName);
		System.out.println("trying to create report file "
				+ this.reportFileName);
		System.out.println("file.exists()=" + file.exists());
		System.out.println("file.canRead()=" + file.canRead());
		System.out.println("file.canWrite()=" + file.canWrite());
		System.out.println("file.canExecute()=" + file.canExecute());
		file.createNewFile();
		return file;
	}

	private File createDQVFile() throws IOException {
		final int ind = this.reportFileName.lastIndexOf(".");
		String DQVFileName;
		DQVFileName = ind != 1 ? this.reportFileName.substring(0, ind) + ".ttl"
				: this.reportFileName + ".ttl";
		final File file = new File(DQVFileName);
		file.createNewFile();
		return file;
	}

	private void writeDQVReport(final Issue issue,
			final RepositoryConnection repCon, final ValueFactory f,
			final String sdate) throws IOException, RDF4JException {
		final ValueFactory factory = SimpleValueFactory.getInstance();

		final String ndqv = "http://www.w3.org/ns/dqv#";
		final String nex = "http://w3id.org/quality/qskos/";

		final IRI ptype = f
				.createIRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
		final IRI pcomputedOn = f.createIRI(ndqv + "computedOn");
		final IRI pdate = f.createIRI("http://purl.org/dc/terms/date");
		final IRI pvalue = f.createIRI(ndqv + "value");
		final IRI pisMeasurementOf = f.createIRI(ndqv + "isMeasurementOf");

		final String datasetName = this.computedOn.substring(
				this.computedOn.lastIndexOf("/") + 1, this.computedOn.length());
		final IRI measure = f
				.createIRI(nex + datasetName
						+ issue.getIssueDescriptor().getName().replace(" ", "")
						+ sdate);
		repCon.add(measure, ptype, f.createIRI(ndqv + "QualityMeasurement"));

		if (this.computedOn.startsWith("http://"))
			repCon.add(measure, pcomputedOn, f.createIRI(this.computedOn));
		else {
			final Value datasetPath = factory.createLiteral(this.computedOn,
					XMLSchema.STRING);
			repCon.add(measure, pcomputedOn, datasetPath);
		}

		final Value ldate = factory.createLiteral(sdate, XMLSchema.DATE);
		repCon.add(measure, pdate, ldate);
		final int i = new Integer(0);
		String res;
		Value lval;
		try {
			final long r = issue.getResult().occurrenceCount();
			if (issue.getResult().isProblematic())
				res = Long.toString(issue.getResult().occurrenceCount());
			else
				res = "0";
			lval = factory.createLiteral(res, XMLSchema.INTEGER);
		} catch (final java.lang.UnsupportedOperationException e) {
			// in case the issue is not associated with a list of elements
			// having the problem the methods occurenceCount is not defined.
			// That happen with the issue "No Common Languages:"
			// then we encode the result as a boolean, plus a annotation
			// explaining .
			if (issue.getResult().isProblematic())
				lval = factory.createLiteral("true", XMLSchema.BOOLEAN);
			else
				lval = factory.createLiteral("false", XMLSchema.BOOLEAN);
		}
		repCon.add(measure, pvalue, lval);

		final IRI uriDimension = f.createIRI(nex + "numOf"
				+ issue.getIssueDescriptor().getName().replace(" ", ""));
		repCon.add(measure, pisMeasurementOf, uriDimension);

	}

	private String createIssueHeader(final IssueDescriptor issueDescriptor) {
		String header = "--- " + issueDescriptor.getName();
		final URL weblink = issueDescriptor.getWeblink();
		header += "\nDescription: " + issueDescriptor.getDescription();

		if (weblink != null) {
			header += "\nDetailed information: " + weblink.toString();
		}
		return header;
	}

	private String getDotFilesPath(final File reportFile) {
		final String absolutePath = reportFile.getAbsolutePath();
		return absolutePath.substring(0,
				absolutePath.lastIndexOf(File.separator));
	}

	private void writeGraphFiles(final Issue issue, final String dotFilesPath)
			throws IOException, RDF4JException {
		final BufferedWriter graphFileWriter = new BufferedWriter(
				new FileWriter(dotFilesPath
						+ issue.getIssueDescriptor().getId() + ".dot"));
		issue.getResult().generateReport(graphFileWriter,
				Result.ReportFormat.DOT);
		graphFileWriter.close();
	}

	private void writeDQVReportBody(final RDFWriter rdfFile,
			final File reportFile, final boolean shouldWriteGraphs)
			throws IOException, RDF4JException {

		final Repository myRepository = new SailRepository(new MemoryStore());
		myRepository.initialize();
		final ValueFactory factory = myRepository.getValueFactory();
		final RepositoryConnection myConnection = myRepository.getConnection();

		// reportWriter.write("* Detailed coverage of each Quality Issue:\n\n");
		final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		final Date date = new Date();
		final String dates = dateFormat.format(date);

		final Iterator<Issue> issueIt = this.issues.iterator();

		while (issueIt.hasNext()) {
			final Issue issue = issueIt.next();
			writeDQVReport(issue, myConnection, factory,
					dateFormat.format(date));
		}

		final RepositoryResult<Statement> myGraph = myConnection.getStatements(
				null, null, null, true);
		try {
			rdfFile.startRDF();
			while (myGraph.hasNext()) {
				rdfFile.handleStatement(myGraph.next());
			}
			rdfFile.endRDF();
		} catch (final RDF4JException e) {
			// oh no, do something!
		} finally {
			myGraph.close();
			myConnection.close();
		}
	}

	private void writeTextReport(final Issue issue, final BufferedWriter writer)
			throws IOException, RDF4JException {
		writer.write(createIssueHeader(issue.getIssueDescriptor()));
		writer.newLine();
		issue.getResult().generateReport(writer, Result.ReportFormat.TXT,
				Result.ReportStyle.SHORT);

		writer.newLine();
		issue.getResult().generateReport(writer, Result.ReportFormat.TXT,
				Result.ReportStyle.EXTENSIVE);

		writer.newLine();
		writer.flush();
	}

}
